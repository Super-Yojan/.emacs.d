# -*- mode: snippet -*-
# name: Rust Plotters CSV Template (Light Theme)
# key: rplot
# --

#+begin_src rust :results file :crates '((plotters . "0.3.5") (plotters-bitmap . "0.3.5"))
use plotters::prelude::*;
use plotters_bitmap::BitMapBackend;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let home = std::env::var("HOME").unwrap();
    
    // --- BRAND COLORS (Light Mode) ---
    let bg_color = RGBColor(255, 255, 255);    // White (#FFFFFF)
    let text_color = RGBColor(15, 23, 42);     // Slate 900 (#0F172A)
    let brand_blue = RGBColor(3, 105, 161);    // Sky 700 (#0369A1)
    let brand_purple = RGBColor(126, 34, 206); // Purple 700 (#7E22CE)
    
    // Define output path
    let file_path = format!("{}/Research/Thrust Analysis/Result/${1:angle_tracking_light}.png", home);
    let root = BitMapBackend::new(&file_path, (1400, 1200)).into_drawing_area();

    root.fill(&bg_color)?;

    // Load CSV Data
    let data_path = format!("{}/${2:data.csv}", home);
    let data: Vec<(f64, f64)> = std::fs::read_to_string(&data_path)?
        .lines()
        .skip(${3:1}) // Skip header row if present
        .filter_map(|line| {
            let parts: Vec<&str> = line.split(',').collect();
            if parts.len() >= 2 {
                let x = parts[0].trim().parse::<f64>().ok()?;
                let y = parts[1].trim().parse::<f64>().ok()?;
                Some((x, y))
            } else {
                None
            }
        })
        .collect();

    if data.is_empty() {
        eprintln!("No data found in {}", data_path);
        return Ok(());
    }

    // Auto-calculate axis ranges
    let x_min = data.iter().map(|(x, _)| *x).fold(f64::INFINITY, f64::min);
    let x_max = data.iter().map(|(x, _)| *x).fold(f64::NEG_INFINITY, f64::max);
    let y_min = data.iter().map(|(_, y)| *y).fold(f64::INFINITY, f64::min);
    let y_max = data.iter().map(|(_, y)| *y).fold(f64::NEG_INFINITY, f64::max);

    // Plot Configuration
    let mut chart = ChartBuilder::on(&root)
        .caption(
            "${4:Angle Tracking Results}", 
            ("sans-serif", 50).into_font().color(&brand_purple)
        )
        .margin(30)
        .x_label_area_size(60)
        .y_label_area_size(60)
        .build_cartesian_2d(x_min..x_max, y_min..y_max)?;

    chart.configure_mesh()
        .x_desc("${5:Time (s)}")
        .y_desc("${6:Angle (deg)}")
        .axis_style(&text_color)
        .bold_line_style(text_color.mix(0.15)) // Lighter grid lines for clean look
        .light_line_style(text_color.mix(0.05))
        .label_style(("sans-serif", 20).into_font().color(&text_color))
        .axis_desc_style(("sans-serif", 25).into_font().color(&text_color))
        .draw()?;

    // Draw Data Series
    chart.draw_series(LineSeries::new(
        data,
        brand_blue.stroke_width(3),
    ))?
    .label("${7:Sensor Data}")
    .legend(move |(x, y)| PathElement::new(vec![(x, y), (x + 20, y)], brand_blue.stroke_width(3)));

    chart.configure_series_labels()
        .background_style(bg_color.mix(0.9))
        .border_style(&text_color)
        .label_font(("sans-serif", 20).into_font().color(&text_color))
        .draw()?;

    root.present()?;
    println!("Plot saved to: {}", file_path);
    
    Ok(())
}
#+end_src